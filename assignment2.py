# -*- coding: utf-8 -*-
"""Assignment2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oC-OWMis5ctUPL9L32YruWdIe4NdL8fV

#Assignment-2 Deep Learning
Stance Detection from Tweet Data

Student Details:
Salina Bharthu(s3736867), Rutvi MacWan(s3773570)

Aim: The aim of this task is to develop the deep learning model for detectig the stance from the given twitter dataset. This notebook contains end to end model building pipeline from Data pre-processing to predicting the target on unseen data.

##Setting up the Notebook
"""

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

import tensorflow as tf
AUTOTUNE = tf.data.experimental.AUTOTUNE
import numpy as np
import pandas as pd

import tensorflow_datasets as tfds
import pathlib
import shutil
import tempfile

from  IPython import display
from matplotlib import pyplot as plt

import nltk
import string
nltk.download('punkt')
nltk.download('stopwords')
from nltk.tokenize import TweetTokenizer
from nltk.corpus import stopwords
from collections import Counter
import re

from tensorflow.keras.layers import Dense, Embedding, GRU, LSTM, Bidirectional, add, Input, Flatten
from tensorflow.keras.models import Sequential
from keras.models import Model
from keras.layers import concatenate
from tensorflow.keras import regularizers, optimizers
import keras.backend as KB


from keras.engine.topology import Layer
import keras.backend as K
from keras import initializers
from keras.layers.normalization import BatchNormalization

# Commented out IPython magic to ensure Python compatibility.
import time
 
logdir = pathlib.Path(tempfile.mkdtemp())/"tensorboard_logs"
shutil.rmtree(logdir, ignore_errors=True)
 
# Load the TensorBoard notebook extension
# %load_ext tensorboard
 
# Open an embedded TensorBoard viewer
# %tensorboard --logdir {logdir}/models

"""**Useful Functions**"""

#Function to plot learning and validation curves
from itertools import cycle
def plot_curve(history_hold, metric = 'binary_crossentropy', ylim=[0.0, 1.0]):
  """
  @param history_hold: History of deep learning model
  @param metric: netric against which the plot needs to be displayed

  @displays a learning and validation curve of model
  """
  cycol = cycle('bgrcmk')
  for name, item in history_hold.items():
    y_train = item.history[metric]
    y_val = item.history['val_' + metric]
    x_train = np.arange(0,len(y_val))

    c=next(cycol)

    plt.plot(x_train, y_train, c+'-', label=name+'_train')
    plt.plot(x_train, y_val, c+'--', label=name+'_val')

  plt.legend()
  plt.xlim([1, max(plt.xlim())])
  plt.ylim(ylim)
  plt.xlabel('Epoch')
  plt.ylabel(metric)
  plt.grid(True)

"""# Data Extraction and Exploration

Data files containing Training and testing data are fetched and explored
"""

stance_df = pd.read_csv("../content/drive/My Drive/Colab Notebooks/data/StanceDataset/train.csv", index_col = None, header = 0, engine = 'python')
stance_df.head()

test_df = pd.read_csv("../content/drive/My Drive/Colab Notebooks/data/StanceDataset/test.csv", index_col = None, header = 0, engine = 'python')
test_df.head()

print("Train Train dataset contains", stance_df.shape[0], 'rows with', stance_df.shape[1], 'variables.')
print("Test Test dataset contains", test_df.shape[0], 'rows with', test_df.shape[1], 'variables.')

# remove any extra whitespace from the data
stance_df = stance_df.applymap(lambda x: x.strip() if type(x) is str else x)
test_df = test_df.applymap(lambda x: x.strip() if type(x) is str else x)

#replacing the None label 
stance_df['Stance'] = stance_df['Stance'].replace("NONE", "NEITHER")
test_df['Stance'] = test_df['Stance'].replace("NONE", "NEITHER")

#Plotting the distribution of data scross stance label classes
stance_df['Stance'].value_counts().plot(kind='bar', color = 'yellowgreen')
plt.xticks(rotation=0)
plt.title("Data Distribution for Dependent 'Stance' variable")

#Plotting the Data distribution against different target and stance labels
tab = pd.crosstab(stance_df['Stance'], stance_df['Target'], margins=True).sort_values('All',ascending=False)
tab = tab.drop('All',axis=1)
tab = tab.drop('All',axis=0)
tab.plot(kind='bar', stacked=False)
plt.xticks(rotation=0)
plt.title("Tweets frequency by 'Target' and 'Stance'")
plt.show()

#Checking dependency between stance and sentiment
from scipy import stats

crosstab = pd.crosstab(stance_df['Stance'], stance_df['Sentiment'])
col_sum = crosstab.sum(axis=0)
col_percents = crosstab/col_sum
print(col_percents)

stat, p, dof, expected = stats.chi2_contingency(crosstab)
print("\n")
print("Chi-square value: ", stat)
print("p-value: ", p)

"""p-value < 0.05 shows that stance and sentiment are independent, therefore, we can discard the sentiment column."""

#Dropping sentiment and opinion towards column
stance_df = stance_df.drop(['Opinion Towards', 'Sentiment'], axis=1)
test_df = test_df.drop(['Opinion Towards', 'Sentiment'], axis=1)

"""#Data Pre-processing
Below mentioned steps are performed to prepare input data for deep learning model
*   Label encoding
*   Tweet text cleaning
*   Tweet and target topic text tokenization and stemming
*   Converting tokenized text corpus to integer encoded representation
*   Normalizing sequences 
*   Train-validation split
"""

df = stance_df.copy()

punct = list(string.punctuation)
stopwordList = stopwords.words('english') + punct +['.', '...', 'k', 'etc', '\"', "\\", "â€œ" ]
tweetTokenizer = nltk.tokenize.TweetTokenizer()
ps = nltk.PorterStemmer()

def process(text, tokeniser = tweetTokenizer):
    """
    Perform the pre-processing of tweets.  

    @param text: the text (tweet) to process
    @param tokeniser: tokeniser to use.
    @param stopwords: list of stopwords to use.
      
    @returns: list of (valid) tokens in text
    """
    text = text.lower()
    text = re.sub("["
                                   u"\U0001F600-\U0001F64F"  # emoticons
                                   u"\U0001F300-\U0001F5FF"  # symbols & pictographs
                                   u"\U0001F680-\U0001F6FF"  # transport & map symbols
                                   u"\U0001F1E0-\U0001F1FF"  # flags (iOS)
                                   u"\U00002702-\U000027B0"
                                   u"\U000024C2-\U0001F251"
                                   "]+", '',text)
    
    
    text = re.sub("@", '', text)
    text = re.sub("#", '', text)
    text = re.sub(r'rt[\s]+', '', text) #retweets
    text = re.sub(r'https?:\/\/\S+', '', text)
    text = re.sub('[0-9]+', '', text) 
    tokens = tokeniser.tokenize(text) 
    tokens = [word for word in tokens if word not in stopwordList]
    
    return tokens

def stemming(text):
  corpus = []
  for word in text:
    word = ps.stem(word)
    corpus.append(word)
  return corpus

from nltk.util import ngrams
def extract_ngrams(data, num):
    n_gram = ngrams(data, num)
    return [' '.join(grams) for grams in n_gram]

"""*Generating padding sequences of text corpus*"""

from tensorflow.python.keras.preprocessing.text import Tokenizer
from tensorflow.python.keras.preprocessing.sequence import pad_sequences

max_length_tweet = 20
max_length_target = 5

def get_padding(tweet_corpus, target_corpus):
  """
    Prepare the padded sequences of text data with numerical representation and similar length

    @param tweet_corpus: Tweet tokens corpus
    @param target_corpus: Target tokens corpus
      
    @returns: Padded sequences of tweet and target data
  """

  tokenizer_obj = Tokenizer() #Keras tokenizer object for tweet
  tokenizer_obj1 = Tokenizer() #Keras tokenizer object for target
  tokenizer_obj.fit_on_texts(tweet_corpus)
  tokenizer_obj1.fit_on_texts(target_corpus)
  word_index_tweet = tokenizer_obj.word_index
  vocab_size_tweet = len(tokenizer_obj.word_index) + 1
  word_index_target = tokenizer_obj1.word_index
  vocab_size_target = len(tokenizer_obj1.word_index) + 1
  
  sequences = tokenizer_obj.texts_to_sequences(tweet_corpus) #transform each word to integer 
  lines_pad = pad_sequences(sequences, maxlen = max_length_tweet, padding = 'post', truncating = 'post') #fixed length sequences 
  
  sequences1 = tokenizer_obj1.texts_to_sequences(target_corpus)
  lines_pad1 = pad_sequences(sequences1, maxlen = max_length_target, padding = 'post', truncating = 'post')
  
  return lines_pad, lines_pad1, vocab_size_tweet, word_index_tweet

from sklearn.preprocessing import LabelEncoder
label_encoder = LabelEncoder()
def DataPrep(df):
  """
  @param df: Dataframe to be used for data preparation
  @returns: padded sequences of tweet text and target data along with vocab size, wod index and Stance data
  """

  df['Stance'] = label_encoder.fit_transform(df['Stance'].values)
  Y = np.eye(3)[df['Stance'].values] 
  df['Token_Tweet'] = df['Tweet'].apply(lambda x: process(x))
  df['Token_Target'] = df['Target'].apply(lambda x: process(x))
  df['Token_Tweet'] = df['Token_Tweet'].apply(lambda x: stemming(x))
  tweet_pad, target_pad, vocab_size, word_index = get_padding(df['Token_Tweet'],df['Token_Target'])
  return tweet_pad, target_pad, vocab_size, word_index, Y

tweet_pad, target_pad, vocab_size, word_index, Y = DataPrep(df)

"""*Creating Bi-grams*"""

df['Bigram_Tweet'] = df['Token_Tweet'].apply(lambda x: extract_ngrams(x,2))
df['Bigram_Target'] = df['Token_Target'].apply(lambda x: extract_ngrams(x,2))
df.head()

bigram_tweet_pad, bigram_target_pad, bigram_vocab_size, bigram_word_index = get_padding(df['Bigram_Tweet'], df['Token_Target'])

#Concatenating tweet and text data to feed into base model
merged_pad = np.concatenate((tweet_pad,target_pad), axis = 1)

"""*Train - Validation split*"""

def get_train_val(lines_pad, df):

  validation_split = 0.15
  category = df['Stance'].values
  indices = np.arange(lines_pad.shape[0])
  np.random.shuffle(indices)
  lines_pad = lines_pad[indices]
  category = category[indices]

  n_values = np.max(category) + 1
  Y = np.eye(n_values)[category]

  num_validation_samples = int(validation_split * lines_pad.shape[0])

  X_train_pad = lines_pad[:-num_validation_samples]
  y_train = Y[:-num_validation_samples]
  X_val_pad = lines_pad[-num_validation_samples:]
  y_val = Y[-num_validation_samples:]
  
  return X_train_pad, y_train, X_val_pad, y_val

X_train_tweet, y_train, X_val_tweet, y_val = get_train_val(tweet_pad, df)
X_train_target, _, X_val_target, _ = get_train_val(target_pad, df)

X_train_merged, y_train_merged, X_val_merged, y_val_merged = get_train_val(merged_pad, df)

X_bigram_train_tweet, y_bigram_train, X_bigram_val_tweet, y_bigram_val = get_train_val(bigram_tweet_pad, df)
X_bigram_train_target, _, X_bigram_val_target, _ = get_train_val(bigram_target_pad, df)

print('Shape of X_train_tweet:', X_train_tweet.shape)
print('Shape of X_val_tweet:', X_val_tweet.shape)

print('Shape of X_train_target:', X_train_target.shape)
print('Shape of X_val_target:', X_val_target.shape)

print('Shape of X_train_merged:', X_train_merged.shape)
print('Shape of X_val_merged:', X_val_merged.shape)

print('Shape of y_train:', y_train.shape)
print('Shape of y_val:', y_val.shape)

def get_callbacks(name):
  return [
    tf.keras.callbacks.TensorBoard(logdir/name)
  ]

"""# Model Building

**Base Model Creation**


*   A very simple classifier Base model is created using Bidirectional LSTM layer followed by output dense layer with 3 output nodes for stance classes and softmax activation 
*   Concatenated tweet text and target data is used as input. The data is fed into embedding layer and 50 dimensions are used for each word representation 
*   'Adam' optimizer with default parameter setup is used
*   For multi class classification problem, categorical cross entropy is used as a loss metric and categorical accuracy is used as a performace measure while model training
*   The model is trained for 50 epochs on both tokenized and bigram data separately
"""

embedding_dim = 50

embedding_layer = Embedding(len(word_index) + 1,
                            embedding_dim,
                            input_length=20,
                            trainable=True)

base_model = Sequential()
base_model.add(embedding_layer)
base_model.add(Bidirectional(LSTM(units=32,  dropout=0.2, recurrent_dropout=0.25)))
base_model.add(Dense(3, activation='softmax'))

base_model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['categorical_accuracy'])

print(base_model.summary())

m_histories = {}
m_histories['BaseModel'] = base_model.fit(
    x = X_train_tweet, 
    y = y_train, 
    validation_data = (X_val_tweet, y_val),
    batch_size=32, 
    epochs=50,
    callbacks=get_callbacks('model/stance'),
    verbose=1)

plot_curve(m_histories, ylim=[0.0, 1.1], metric = 'categorical_accuracy')

"""A Base Model with only Tweet Tokens data as an input showed a huge overfitting as shown in above plot.
Below mentioned experiments are performed on base model for analysis purposes:


*   Base model with tweet and target concatenated input
*   Base model with embedding layer weights initialized using glove matrix
*   Base model with glove matrix and tweet, target merged input
*   Base model with bigrams as an input
"""

m_histories['BaseModel_bigram'] = base_model.fit(
    x = X_bigram_train_tweet, 
    y = y_bigram_train, 
    validation_data = (X_bigram_val_tweet, y_bigram_val),
    batch_size=32, 
    epochs=50,
    callbacks=get_callbacks('model/stance'),
    verbose=1)

plot_curve(m_histories, ylim=[0.0, 1.1], metric = 'categorical_accuracy')

"""Above validation and training curve shows that basemodel is not able to extract any important features, therefore, model complexity needs to be increased. Also, discarding bi-gram data as it is showing comparitively poor results as compared to the tokenized data.

## Transfer Learning using GloVe
Glove model is pre trained on twitter data and can be useful if employed for the task utilizing similar data. After few manual trials on 50, 100 and 200 dimensional glove matrix, 100 dimensional glove matrix is used.

**Note:** Showing experiments of all the 3 gloves used to trigger session crash. Therefore, only finalized experiment is represented below.
"""

file = open("/content/drive/My Drive/Colab Notebooks/glove_data.txt/glove.twitter.27B.100d.txt", encoding='utf-8')

glove_vectors = dict()
for line in file:
  values = line.split()
  word = values[0]
  features = np.asarray(values[1:])
  glove_vectors[word] = features
file.close()

len(glove_vectors)

from tqdm import tqdm
def generate_pretrained_embedding_matrix(glove_vectors, dimension, vocab_size, word_index):
    embedding_matrix=np.zeros((vocab_size,dimension))
    for word,i in tqdm(word_index.items()):
        if i > vocab_size:
            continue
        if word in glove_vectors:  
            emb_vec=glove_vectors[word]
            embedding_matrix[i]=emb_vec
    return embedding_matrix

embedding_matrix = generate_pretrained_embedding_matrix(glove_vectors, 100, vocab_size, word_index)

"""## Base Model with GloVe"""

embedding_dim = 200

embedding_layer = Embedding(len(word_index) + 1,
                            embedding_dim,
                            weights = [embedding_matrix],
                            input_length=20,
                            trainable=False)

base_model_glove = Sequential()
base_model_glove.add(embedding_layer)
base_model_glove.add(Bidirectional(LSTM(units=32,  dropout=0.2, recurrent_dropout=0.25)))
base_model_glove.add(Dense(3, activation='softmax'))

base_model_glove.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['categorical_accuracy'])

print(base_model_glove.summary())

m_histories['BaseModelGlove'] = base_model_glove.fit(
    x = X_train_tweet, 
    y = y_train, 
    validation_data = (X_val_tweet, y_val),
    batch_size=32, 
    epochs=50,
    callbacks=get_callbacks('model/stance'),
    verbose=1)

plot_curve(m_histories, ylim=[0.0, 1.1], metric = 'categorical_accuracy')

"""By using weights from pre-trained glove model into embedding layer of only tweet text data, the performace seems to be slightly increased. Next, we are trying to input merged data (tweet + target)."""

m_histories['BaseModelGloveMerged'] = base_model_glove.fit(
    x = X_train_merged, 
    y = y_train, 
    validation_data = (X_val_merged, y_val),
    batch_size=32, 
    epochs=50,
    callbacks=get_callbacks('model/stance'),
    verbose=1)

plot_curve(m_histories, ylim=[0.0, 1.1], metric = 'categorical_accuracy')

"""Curves of merged data shows the least overfitting in the base model. Therefore, we can further experiment to increase the complexity of the model as well as we can provide two different inputs for each Tweet and its Target topic.

## Final Model Development

* The final model consist of embedding layer for tweet text
*   Input length for Tweet was fixed to 20 and that of Target topic was fixed to 5
*   The weights of pre-trained embedding matrix using 100d GloVe Twitter vector, are used for tweet embedding layer
*   Tweet embedding layer is encoded using Bidirectional LSTMs. Weights of forward and backward pass of target encoding Bidirectional LSTM layer are captured and further used as initial state inputs for tweet encoding layer
*   A flatten layer was also introduced to convert the data into one-dimensional phase
*   â€˜ReLuâ€™ activation function was applied to hidden dense layers as it can help achieve faster convergence of optimizers.
*   L2-regularizers and dropouts were also introduced at each hidden layer to prevent the model from overfitting.
"""

#Reshape target data to use as input in Bidirectional LSTM layer
X_train_target = X_train_target.reshape(X_train_target.shape[0], X_train_target.shape[1], 1)
X_val_target = X_val_target.reshape(X_val_target.shape[0], X_val_target.shape[1], 1)

def create_model(neurons = 30, dropout = 0.1, reg = 0.01, ilr = 0.001):
  tweet = Input(shape = (max_length_tweet, ))
  target = Input(shape = (max_length_target, 1))

  emb_tweet = Embedding(vocab_size, 
                        100, 
                        weights = [embedding_matrix], 
                        input_length=max_length_tweet, 
                        trainable=False)(tweet)
  
  target_encoding_layer = Bidirectional(LSTM(neurons,
                                                dropout=dropout,
                                                recurrent_dropout=0.2,
                                                return_state=True, 
                                                return_sequences=False, #return full sequence
                                            kernel_regularizer=regularizers.l2(reg)), merge_mode = 'concat')

  tweet_encoding_layer = Bidirectional(LSTM(neurons,
                                            dropout=dropout,
                                            recurrent_dropout=0.2,
                                            return_state=False,
                                            return_sequences=True, #return the last output sequence
                                            kernel_regularizer=regularizers.l2(reg), unroll=True,
                                            activity_regularizer=regularizers.l2(reg)), merge_mode= 'concat')

  (target_encoding, target_fw_state_h, target_fw_state_s, target_bw_state_h, target_bw_state_s) = target_encoding_layer(target)
  tweet_encoding = tweet_encoding_layer(emb_tweet, initial_state=[target_fw_state_h, target_fw_state_s, target_bw_state_h, target_bw_state_s])

  #Fully connected layers
  next_layer = Dense(neurons, activation='relu', kernel_regularizer=regularizers.l2(reg))(tweet_encoding)
  next_layer1 = Dense(neurons//2, activation='relu', kernel_regularizer=regularizers.l2(reg))(next_layer)
  
  flat_layer = Flatten()(next_layer1)

  #Outou dense layer for 3 stance classes
  out_layer = Dense(3, activation='softmax')(flat_layer)

  #Decaying learning rate for Adam optimizer
  lr_schedule = optimizers.schedules.ExponentialDecay(
      initial_learning_rate=ilr,
      decay_steps=10000,
      decay_rate=0.9)
  opt = optimizers.Adam(learning_rate=lr_schedule)

  model = Model(inputs = [tweet, target], outputs = out_layer)
  model.compile(loss='categorical_crossentropy', optimizer=opt, metrics=['categorical_accuracy'])
  print(model.summary())
  return model

"""Initially, Training model by using random parameter setup which are further tuned"""

histories = {}
model = create_model(neurons = 40, dropout = 0.01, reg = 0.001)
histories['GloV_Enc'] = model.fit(
    x = [X_train_tweet, X_train_target], 
    y = y_train,
    batch_size=32, 
    epochs=50, 
    validation_data=([X_val_tweet, X_val_target], y_val), 
    callbacks=get_callbacks('model/stance'), 
    verbose=1)

plot_curve(histories, metric='categorical_accuracy', ylim=[0.0, 1.0])

"""The plot shows that model still overfits the data, therefore, parameters tuning is performed to obtain optimal set of parameters.

# Model Tuning

Below mentioned parameters are tuned:
![image.png](data:image/png;base64,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)
"""

def tune_model(hp):
  tweet = Input(shape = (max_length_tweet, ))
  target = Input(shape = (max_length_target, 1))

  emb_tweet = Embedding(vocab_size, 
                        100, 
                        weights = [embedding_matrix], 
                        input_length=max_length_tweet, 
                        trainable=False)(tweet)

  # Selects the parameter randomly
  neurons = hp.Choice('neurons', [30, 45, 60])
  dropout = hp.Choice('dropout', [0.1, 0.3, 0.5])
  reg = hp.Choice('reg', [0.1, 0.01, 0.001])
  ilr = hp.Choice('ilr', [0.1, 0.01, 0.001])

  target_encoding_layer = Bidirectional(LSTM(neurons,
                                                dropout=dropout,
                                                recurrent_dropout=0.2,
                                                return_state=True,
                                                return_sequences=False,
                                            kernel_regularizer=regularizers.l2(reg)), merge_mode = 'concat')

  tweet_encoding_layer = Bidirectional(LSTM(neurons,
                                            dropout=dropout,
                                            recurrent_dropout=0.2,
                                            return_state=False,
                                            return_sequences=True,
                                            kernel_regularizer=regularizers.l2(reg), unroll=True,
                                            activity_regularizer=regularizers.l2(reg)), merge_mode= 'concat')

  (target_encoding, target_fw_state_h, target_fw_state_s, target_bw_state_h, target_bw_state_s) = target_encoding_layer(target)
  tweet_encoding = tweet_encoding_layer(emb_tweet, initial_state=[target_fw_state_h, target_fw_state_s, target_bw_state_h, target_bw_state_s])

  next_layer = Dense(neurons, activation='relu', kernel_regularizer=regularizers.l2(reg))(tweet_encoding)
  next_layer1 = Dense(neurons//2, activation='relu', kernel_regularizer=regularizers.l2(reg))(next_layer)
  flat_layer = Flatten()(next_layer1)
  out_layer = Dense(3, activation='softmax')(flat_layer)

  lr_schedule = optimizers.schedules.ExponentialDecay(
      initial_learning_rate=ilr,
      decay_steps=10000,
      decay_rate=0.9)
  opt = optimizers.Adam(learning_rate=lr_schedule)

  model = Model(inputs = [tweet, target], outputs = out_layer)
  model.compile(loss='categorical_crossentropy', optimizer=opt, metrics=['categorical_accuracy'])
  #print(model.summary())
  return model

# installing kerastuner
!pip install -q -U keras-tuner

# Building the Random Search Tuner
import kerastuner
from tensorflow import keras
from tensorflow.keras import layers
from kerastuner.tuners import RandomSearch

MAX_TRIALS = 20
EXECUTIONS_PER_TRIAL = 10
tuner = RandomSearch(
    tune_model,
    objective='val_categorical_accuracy',
    max_trials=MAX_TRIALS,
    executions_per_trial=EXECUTIONS_PER_TRIAL,
    directory='tune_dir',
    project_name='tune_optimizer',
    seed=42
)

"""**WARNING:  *Session may crash.***

Parameter tuning is being performed in the next tab.
"""

TRAIN_EPOCHS = 10
tuner.search(x = [X_train_tweet, X_train_target],
             y=y_train,
             epochs=TRAIN_EPOCHS,
             validation_data=([X_val_tweet,X_val_target], y_val))

tuner.oracle.get_best_trials(num_trials=1)[0].hyperparameters.values

"""**Now, let's build the model using optimal set of parameters.**"""

t_histories = {}
model = create_model(neurons = 60, dropout = 0.1, reg = 0.01, ilr = 0.01)
t_histories['tunedModel'] = model.fit(
    x = [X_train_tweet, X_train_target], 
    y = y_train,
    batch_size=32, 
    epochs=50, 
    validation_data=([X_val_tweet, X_val_target], y_val), 
    callbacks=get_callbacks('model/stance'), 
    verbose=1)

plot_curve(t_histories, metric='categorical_accuracy', ylim=[0.0, 1.0])

plot_curve(t_histories, metric='loss', ylim=[0.9, 1.5])

#Average categorical accuracy during training
model.evaluate([X_train_tweet, X_train_target], y_train)

"""The above performance curves shows the steady learning and validation patterns depicting very weak learning of task specific features. 
The issue of overfitting is resolved.
Decaying learning rate with Adam optimizer is used to deal with local minima issue which can be the reason for such model behaviour.
Slight improvement is observed after all the manual experiments, however, the model seems to be not generalizing well across stance classes. Further, the model is evaluated on unseen data.

##Model Evaluation on Unseen test Data
"""

import sklearn
from sklearn.metrics import classification_report
def evaluate(tweet_pad, target_pad, y_val):
  """
  @param tweet_pad and target_pad : tweet and target padded sequences 
  @param y_val : Stance label for validation

  @displays classification report considerring predicted values
  """

  y_pred = model.predict(
    [tweet_pad,target_pad] , batch_size=32, verbose=1)
  
  y_pred = np.argmax(y_pred, axis=1)
  y_val = np.argmax(y_val, axis=1)
  labels = {'Against': 0, 'Favor': 1, 'Neither': 2}
  labels2 = dict((v,k) for k,v in labels.items())
  predictions = [labels2[k] for k in y_pred]
  actual_test_labels = [labels2[k] for k in y_val]
  cm = classification_report(actual_test_labels, predictions)
  print(cm)

tweet_test_data, target_test_data,_,_, test_Y = DataPrep(test_df)

evaluate(tweet_test_data, target_test_data, test_Y)

"""Built model showed an accuracy of 0.44 with macro f1-score of 0.31 over unseen test dataset. There exists difficulties classifying the stance in Favor of the target.

##Independent Evaluation

Tweets belonging to Target topics other than given in training data, were also explored for independent evluation.
"""

eval_df = pd.read_excel("/content/drive/My Drive/Colab Notebooks/TweetDataDL2.xlsx")
eval_df.head()

tweet_unseen_data, target_unseen_data,_,_, unseen_Y = DataPrep(eval_df)

evaluate(tweet_unseen_data, target_unseen_data, unseen_Y)